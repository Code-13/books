---
date: 2021-12-24
cover: https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2021/12/24/20211224143719.jpeg
---

# 高效并发

## Java 内存模型与线程

并发处理的广泛应用是 Amdahl 定律取代摩尔定律成为计算机性能发展源动力的根本原因。

### 概述

让计算机同时去做几件事情，一个很重要的原因是计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都被花费在磁盘I/O、网络通信或者数据库访问上。

衡量一个服务性能的高低好坏，TPS(Transactions Per Second，每秒事务数)是重要的指标，它代表一秒内服务器能响应的请求总数，TPS 值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁争用数据，互相阻塞，甚至死锁，将会大大降低程序的并发能力。

无论语言、中间件和框架再如何先进，开发人员都不应期望它们能独立完成所有并发处理的事情，了解并发的内幕仍然是成为一个高级程序员不可缺少的课程。

### 硬件效率与一致性

物理机遇到的并发问题与虚拟机中的情况有很多相似之处，物理机对并发的处理方案对虚拟机的实现也有相当大的参考意义。

"让计算机并发执行若干个运算任务" 与 "更充分的领用计算机处理器的效能" 之间的因果关系并没有想象中的简单，其中的重要的复杂性是绝大多数的运算任务都不可能只靠处理器"计算"就能完成。处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作是很难消除的(无法仅靠寄存器来完成所有的运算任务)。由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或者多层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到告诉缓存中，让运算能快速进行，当运算结果结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。

基于高速缓存的存储交互很好的解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度：缓存一致性(Cache Coherence)。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统称为共享内存多核系统(Shared Memory Multiprocessors System)，如图所示：

![5-12-1.drawio.png](https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2021/12/28/20211228105102.png)


当多个处理器的运算任务都设计同一块主内存区域，将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存时该以谁的缓存数据为准呢？为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议有 MSI、MESI(Illinois Protocol)、MOSI、Synapse、Firefly及 Dragon Protocol等。内存模型可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。

除了高速缓存，处理器可能会对输入代码进行乱序执行优化。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序(Instruction Reorder)优化。

### Java 内存模型

《Java虚拟机规范》中曾试图定义一种 “Java 内存模型”（Java Momory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果。

::: tip
定义Java内存模型并非一件容易的事情，这个模型必须足够严谨，才能让 Java 的并发访问操作不会产生歧义；但是也必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性来获取更好的执行速度。经过漫长的验证与修补，直至 JDK5 (实现了 JSR-133)发布后，Java内存模型才终于成熟、完善起来。
:::

#### 主内存与工作内存

Java内存模型的主要目的是定义程序中的各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
::: tip
此处的变量包括了示例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数。
:::

**Java内存模型规定了所有的变量都储存在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示：**

![5-12-2.drawio.png](https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2021/12/28/20211228105140.png)


::: warning
这里所讲的主内存、工作内存和Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有关系的。
如果硬要将两者勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优选存储于寄存器和告诉缓存中，因为程序运行时主要访问的是工作内存。
:::

#### 内存间的交互操作

关于主内存于工作内存之间的具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了8中操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的：

- lock：作用于主内存的变量，他把一个变量标识为一条线程独占的状态
- unlock：作用于主内存的变量，他把一个处于锁定状态的变量释放出来
- read：作用于主内存的变量，他把一个变量从主内存中传输至工作内存中
- load：作用于工作内存的变量，它把read操作从主内存得到的变量值放入工作内存的变量副本中
- use：作用于工作内存的变量，它把工作内存中的一个变量传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign：作用于工作内存的变量，它把一个从执行引擎得到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store：作用域工作内存的变量，它把工作内存的一个变量值传送到主内存中
- write：作用域主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就需要按顺序执行 store 和 write 操作。除此之外，Java内存模型还规定了子执行上述8中基本操作时必须满足如下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现
- 不允许一个线程丢弃它最近的assign操作
- 不允许一个线程无原因地把数据从线程的工作内存同步回主内存中
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次lock后，只有执行相同次数的unlock操作，变量才会解锁。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值
- 如果一个变量事先没有被 lock 锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中。

::: tip
这8中内存访问操作以及上述规则限定，再加上volatile的一些特殊规定，就已经能准确描述出Java程序中哪些内存访问操作再并发下才是安全的。
但是这种定义虽然相当严谨，但也极为烦琐，实践起来更是无比麻烦。Java团队后续将内存模型简化为 read、write、lock和unlock，但这只是语言描述上的等价化简，Java内存模型的基础设计任然没有改变。
对于非虚拟机开发的普通开发人员来说，只需理解Java内存模型的定义即可，无需以这种思维思考并发问题。
:::

#### 对于 volatile 变量的特殊规则

当一个变量定义为 volatile 之后，它具备两个特性：
1. 保证此变量对所有线程的可见性，这里的可见性指的是当一个线程修改了这个变量的值，新值对于其他线程来说是立即可知的。
2. 禁止指令重排序优化

##### 可见性

volatile 变量在各个线程的工作内存中是不存在一致性问题的，但是 Java 里面的运算操作符并非原子操作，这导致 volatile 变量在并发下一样是不安全的。

示例：

```java
public class VolatileTest {

  static volatile int race = 0;

  static void increase() {
    race++;
  }

  static final int THREAD_COUNT = 20;

  @Test
  @DisplayName("test")
  void test() throws InterruptedException {
    Thread[] threads = new Thread[THREAD_COUNT];

    for (int i = 0; i < THREAD_COUNT; i++) {
      threads[i] =
          new Thread(
              () -> {
                for (int j = 0; j < 10000; j++) {
                  increase();
                }
              });

      threads[i].start();
    }

    for (Thread thread : threads) {
      thread.join();
    }

    System.out.println(race);
  }
}
```

这个代码发起了 20 个线程，每个线程对 race 变量进行 10000 次自增操作，如果正确并发的话，最后的正确结果应该是 200000。但是运行结果总是小于 200000。

原因就出在 `race++` 中，javap 反编译后得到字节码：

```java
static void increase();
  Code:
      0: getstatic     #7                  // Field race:I
      3: iconst_1
      4: iadd
      5: putstatic     #7                  // Field race:I
      8: return
```

从字节码的层面上就可以分析出并发失败的原因：当 getstatic 指令把 race 值取到字节码栈顶的时候，volatile 关键字保证了 race 的值在此时是正确的，但是在执行 iconst_1 、iadd 这些指令的时候，其他线程可能已经将 race 的值改变了，而当前线程操作栈顶的值就变成了过期数据，所以 putstatic 指令就可能将较小的值同步回主内存之中。

::: warning 字节码分析并发的问题
使用字节码来分型并发问题是不严谨的，因为即使编译出来的只有一条字节码指定，也不意味着这条指令就是一个原子操作。一条字节码指令可以在解释执行时，解释器需要运行许多行代码才能实现它的语义。如果时编译执行，一条字节码指令也可能转化成若干条本地机器码指令。
:::

由于 volatile 只能保证变量的可见性，在不符合一下规则的运算场景中，仍然需要通过加锁来保证原子性：

1. 运算结果并不依赖当前的值，或者确保只有单一的线程修改变量的值。
2. 变量不需要与其他的状态变量共同参与不变约束。

##### 禁止指令重排序

普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是 Java 内存模型中描述的所谓 ”线程内表现为串行的语义“ (Within-Thread As-If-serial Semantics)。

以下的伪代码示例演示为何指令重排序会干扰程序的执行：

```java
Map configOptions;
char[] configText;

// 此变量必须使用 volatile 修饰
volatile boolean initialized = false

// 假设以下代码在线程 A 中执行
// 模拟读取配置信息，当读取完成后将 initialized 设置为 true，通知其他线程配置可用
configOptions = new HashMap();
configText = readCOnfigFile(fileName);
processConfigOptions(configText, configOptions);
initialized = true;

// 假设一下代码在线程 B 中执行
// 等待 initialized 为 true，代码线程 A 已经把配置信息初始化完成
while(!initialized){
  sleep();
}
// 使用线程 A 初始化好的配置信息
doSomeThingWithConfig();
```

如果 initialized 没有使用 volatile 修饰，就可能会由于指令重排序的优化，导致线程 A 的最后一段代码 `initialized = true;` 被提前执行，这样在线程 B 中使用配置信息的代码就可能会出现错误，volatile 能避免这种情况。

Java内存模型中对 volatile 变量定义的特殊规则的定义。假设 T 表示一个线程，V 和 W 分别表示两个 volatile 型变量，那么在进行 read、load、use、assign、store和write操作时需要满足以下规则：

- 只有当线程 T 对变量 V 执行的前一个动作是 load 时，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候可以认为是和线程 T 对变量 V 的 load、read 动作相关联的，必须连续且一起出现。
- 只有当线程 T 对变量 V 执行的前一个动作是 assign 的时候，线程 T 才能对变量 V 执行 store 动作；并且，只有当线程 T 对变量 V执行的后一个动作是 store 的时候，线程 T 才能对变量 V 执行 assign 动作。线程 T 对变量 V 的 assign 动作可以认为是和线程 T 对变量 V 的 store、write 动作相关联，必须连续且一起出现。
- 假定动作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定动作 F 是和动作 A 相关联的 load 或 store 动作，假定动作 P 是和动作 F 相应的对变量 V 的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或 assign动作，假定动作 G 是和动作B相关联的 load 或 store 动作，动作 Q 是和动作G相应的对变量 W 的 read 或 write 动作。如果 A 先于 B，那么 P 先于 Q。

#### 针对 long 和 double 型变量的特殊规则

Java内存模型要求八种操作都具有原子性，但是对于 64 位的数据类型，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64位数据的读写操作划分为两次 32 的操作来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的 load 、store、read和write这四个操作的原子性，这就是所谓的 ”long 和 double的非原子性协定“

**在实际的开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的 long 和 double 变量专门声明为 volatile。**

#### 原子性、可见性、有序性

##### 原子性（Atomicity）

由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store和write这六个，基本类型的访问、读写都是具备原子性的。如果需要一个更大范围的原子性保证，JMM 提供了 lock 和 unlock 操作来满足，虽然虚拟机没有这两个操作直接开放给用户，却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。反映到Java代码就是 synchronized。

##### 可见性（Visibility）

`volatile` 保证了多线程操作时变量的可见性。
`synchronized` 和 `final` 也能实现可见性。同步块的可见性是由 ”对一个变量执行 unlock 之前，必须先把变量同步回主内存中“ 这条规则获得的。

final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看到 final 字段的值。

::: danger this 引用逃逸
this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到”初始化一半“的对象。
:::

##### 有序性（Ordering）

Java 程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

Java语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。volatile 关键字本身就包含了禁止指令出排序的语义，而 synchronized 则是由 ”一个变量在同一时刻只允许一条线程对其进行 lock 操作“ 这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行的进入。

绝大多数并发控制操作都能使用 synchronized 关键字来完成。synchronized 这种万能的特性间接导致了被程序员的滥用以及越大的性能影响。
