---
date: 2021-10-27
cover: https://img2.doubanio.com/view/subject/l/public/s7663093.jpg
---

# 第一部分 基础知识

[TOC]

第一部分（第2章~第5章）重点介绍了并发性和线程安全性的基本概念，以及如何使用类库提供的基本并发构建块来构建线程安全类。在第一部分给出了一个清单，其中总结了这一部分中介绍的最重要的规则。

第2章与第3章构成了本书的基础。在这两章中给出了几乎所有用于避免并发危险、构造线程安全的类以及验证线程安全的规则。如果读者重“实践”而轻“理论”，那么可能会直接跳到第二部分，但在开始编写任何并发代码之前，一定要回来读一读这两章！

第4章介绍了如何将一些小的线程安全类组合成更大的线程安全类。

第5章介绍了在平台库中提供的一些基础的并发构建模块，包括线程安全的容器类和同步工具类。

## 线程安全性

### 什么是线程安全性

> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

### 原子性

#### 竞态条件 Race Condition

> 当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件
> 大多是竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算

> 先检查后执行是最常见的竞态条件
> 读取-修改-写入 是另一种竞态条件

#### 原子操作

> 要避免竞态条件问题，就必须在某个线程修改变量时，通过**某种方式**防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中

> 原子操作是指，对于访问同一个状态的所有操作(包含该操作本身)来说，这个操作是一个以原子方式执行的操作
> 原子性：一组操作，要么全部执行，要么全部不执行

> 复合操作：包含了一组必须以原子方式执行的操作

### 加锁机制

> 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

#### 内置锁 `synchronized`

> 同步代码块包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块

```java
synchronized (lock) {
 // 访问或者修改由锁保护的共享状态
}
```

> 每个 Java 对象都可以作为一个实现同步的锁，这个锁统称为内置锁(Intrinsic Lock)或者监视器锁(Monitor Lock)
> Java 的内置锁是一种互斥锁

#### 可重入

Java 内置锁是可重入的

如果不可重入，可能会发生死锁

### 性能

> 通常，在简单性与性能之间存在相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能二牺牲简单性

> 当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁

## 对象的共享

> 同步还有另外一个重要的方面：内存可见性。我们不仅希望防止某个线程正在使用对象状态而另一个线程同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化

### 可见性

> 可见性时一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。

> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。即指令重排序

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。

#### `Volatile` 变量

- 被 `Volatile` 修饰的变量禁止指令重排序
- 保证可见性

> 仅当 volatile变量能简化代码的实现以及对同步策略的验证时，才使用

volatile 变量的正确使用方式：

- 确保它们自身状态的可见性
- 确保它们所引用对象的状态的可见性
- 标识一些重要的程序生命周期事件的发生

volatile 变量的局限性

- 不足以确保递增操作的原子性

何时使用 volatile 变量

- 对变量的写入操作不依赖变量的当前值，或者确保只有单个线程更新变量的值。
- 该变量不会与其他状态一起纳入不变性条件中
- 在访问变量时不需要加锁

### 线程封闭

> 当某个对象封闭在一个线程中时，这种用法将自动实现线程安全，即使被封闭的对象本身线程不安全

#### Ad-hoc 线程封闭

> 维护线程封闭性的职责完全由程序徐实现来承担。非常脆弱

#### 栈封闭

> 局部变量的固有属性之一就是封闭在执行线程中

#### ThreadLocal 类

> ThreadLocal 使线程中的某个值与保存值的对象关联起来

### 不变性

> 不可变对象一定是线程安全的

不可变对象需要满足的条件：

- 对象创建之后其状态就不能修改
- 对象的所有域都是 final
- 对象是正确创建的

### 总结

在并发程序中使用和共享对象时，可以采用一些实用的策略：

- 线程封闭
- 只读共享
- 线程安全共享
- 保护对象



## 对象的组合

将现有的线程安全组件组合成更大规模的组件或程序

### 设计线程安全的类

在设计线程安全的类的过程中，需要包含一下三个基本要素：

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

#### 收集同步需求

确保类的线程安全性，就需要确保它的不变性不会在并发访问的情况下被破坏。对象与变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final 类型的域使用的越多，就越能简化对象可能状态的分析过程。在极端状态下，不可变对象只有唯一的状态。

许多类都定义了一些**不变性条件**，用于判断状态是有效的还是无效的。



在操作中还会包含一些**后验条件**来判断状态迁移是否是有效的。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。

由于不变性条件以及后验条件在状态及状态转换上施加了各种约束，因此就需要额外的同步与封装。

在类中也可以包含同时约束多个状态变量的不变性条件。这些相关的变量必须在单个原子操作中进行读取或更新。

`如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。`

#### 依赖状态的操作

如果在某个操作中包含有基于状态的先验条件，那么此操作被称为依赖状态的操作。

> 先验条件（Precondition），例如不能从空队列中移除元素，在删除元素之前，队列必须处于非空状态

在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作。

在Java中，等待某个条件为真的各种内置机制（包括等待和通知等机制）都与内置加锁机制紧密关联，要想正确地使用它们并不容易。要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（例如阻塞队列[Blocking Queue]或信号量[Semaphore]）来实现依赖状态的行为。

#### 对象的所有权

在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据。所有权（Ownership）在Java中并没有得到充分的体现，而是属于类设计中的一个要素。

> 如果分配并填充了一个HashMap对象，那么就相当于创建了多个对象：HashMap对象，在HashMap对象中包含的多个对象，以及在Map.Entry中可能包含的内部对象。

无论如何，垃圾回收机制使我们避免了如何处理所有权的问题。

许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。

容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。

### 实例封闭

确保可以该对象只能由单个线程访问（线程封闭），或者通过一个锁来保护对该对象的所有访问。确保该**对象只能由单个线程访问（线程封闭**），或者**通过一个锁来保护对该对象的所有访问**。

封装简化了线程安全类的实现过程，它提供了一种实例封闭机制（`InstanceConfinement`），通常也简称为“封闭”[CPJ 2.3.3]。

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

被封闭对象一定不能超出它们既定的作用域。对象可以封闭在类的一个实例（例如作为类的一个私有成员）中，或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程之间共享该对象）。当然，对象本身不会逸出——出现逸出情况的原因通常是由于开发人员在发布对象时超出了对象既定的作用域。



```java
@ThreadSafe
public class PersonSet{
  
  	@GuardedBy（"this"）
  	private final Set＜Person＞mySet=new HashSet＜Person＞（）；
  
    public synchronized void addPerson（Person p）{
      mySet.add（p）；
    }
  
  	public synchronized boolean containsPerson（Person p）{
      return mySet.contains（p）；
    }
}
```

> PersonSet说明了如何通过封闭与加锁等机制使一个类成为线程安全的（即使这个类的状态变量并不是线程安全的）。
>
> PersonSet的状态由HashSet来管理的，而HashSet并非线程安全的。但由于mySet是私有的并且不会逸出，因此HashSet被封闭在PersonSet中。
>
> 唯一能访问mySet的代码路径是addPerson与containsPerson，在执行它们时都要获得PersonSet上的锁。PersonSet的状态完全由它的内置锁保护，因而PersonSet是一个线程安全的类。



实例封闭是构建线程安全类的一个最简单方式，它还使得在锁策略的选择上拥有了更多的灵活性。



当然，如果将一个本该被封闭的对象发布出去，那么也能破坏封闭性。如果一个对象本应该封闭在特定的作用域内，那么让该对象逸出作用域就是一个错误。当发布其他对象时，例如迭代器或内部的类实例，可能会间接地发布被封闭对象，同样会使被封闭对象逸出。

封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。

#### Java 监视器模式

从线程封闭原则及其逻辑推论可以得出Java监视器模式.

> 虽然Java监视器模式来自于Hoare对监视器机制的研究工作（Hoare，1974），但这种模式与真正的监视器类之间存在一些重要的差异。进入和退出同步代码块的字节指令也称为monitorenter和monitorexit，而Java的内置锁也称为监视器锁或监视器。

在某些情况下，程序需要一种更复杂的同步策略。Java监视器模式的主要优势就在于它的简单性。

**Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。**

使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁），有许多优点。

- 私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便（正确或者不正确地）参与到它的同步策略中。
- 要想验证某个公有访问的锁在程序中是否被正确地使用，则需要检查整个程序，而不是单个的类。

#### 示例：车辆追踪

一个用于调度车辆的“车辆追踪器”，例如出租车、警车、货车等。首先使用监视器模式来构建车辆追踪器，然后再尝试放宽某些封装性需求同时又保持线程安全性。

每台车都由一个String对象来标识，并且拥有一个相应的位置坐标（x, y）。在`VehicleTracker`类中封装了车辆的标识和位置，因而它非常适合作为基于MVC（Model-View-Controller，模型-视图-控制器）模式的GUI应用程序中的数据模型，并且该模型将由一个视图线程和多个执行更新操作的线程共享。视图线程会读取车辆的名字和位置，并将它们显示在界面上:

```java
@ThreadSafe
public class MonitorVehicleTracker {

  private final Map<String, MutablePoint> locations;

  public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
    this.locations = deepCopy(locations);
  }

  public synchronized Map<String, MutablePoint> getLocations() {
    return deepCopy(locations);
  }

  public synchronized MutablePoint getLocation(String id) {
    MutablePoint loc = locations.get(id);
    return loc == null ? null : new MutablePoint(loc);
  }

  public synchronized void setLocation(String id, int x, int y) {
    MutablePoint loc = locations.get(id);
    if (loc == null) {
      throw new IllegalArgumentException("No Such ID:" + id);
    }
    loc.x = x;
    loc.y = y;
  }

  private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
    Map<String, MutablePoint> result = new HashMap<>();
    for (String id : m.keySet()) {
      result.put(id, m.get(id));
    }
    return Collections.synchronizedMap(result);
  }
}

@Terrible
@NotThreadSafe
public class MutablePoint {

  int x;

  int y;

  public MutablePoint() {
    x = 0;
    y = 0;
  }

  public MutablePoint(MutablePoint p) {
    x = p.x;
    y = p.y;
  }
}
```

### 线程安全性的委托

大多数对象都是组合对象。

当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式是非常有用的。但是，**如果类中的各个组件都已经是线程安全的，会是什么情况呢？我们是否需要再增加一个额外的线程安全层？**

答案是“**视情况而定**”。在某些情况下，通过多个线程安全类组合而成的类是线程安全的，而在某些情况下，这仅仅是一个好的开端。

#### 示例：基于委托的车辆追踪器

面将介绍一个更实际的委托示例，构造一个委托给线程安全类的车辆追踪器。我们将车辆的位置保存到一个Map对象中，因此首先要实现一个线程安全的Map类，`ConcurrentHashMap`。我们还可以用一个不可变的 `Point` 类来代替 MutablePoint 以保存位置

```java
@Immutable
public class Point {

  final int x;
  final int y;

  public Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}
```

```java
@ThreadSafe
public class DelegatingVehicleTracker {

  private final ConcurrentMap<String, Point> locations;
  private final Map<String, Point> unmodifiableMap;

  public DelegatingVehicleTracker(Map<String, Point> points) {
    locations = new ConcurrentHashMap<>(points);
    unmodifiableMap = Collections.unmodifiableMap(locations);
  }

  public Map<String, Point> getLocations() {
    return unmodifiableMap;
  }

  public Point getLocation(String id) {
    return locations.get(id);
  }

  public void setLocation(String id, int x, int y) {
    if (locations.replace(id, new Point(x, y)) == null) {
      throw new IllegalArgumentException("invalid vehicle name: " + id);
    }
  }
}
```

需要注意的是，我们稍微改变了车辆追踪器类的行为。在使用监视器模式的车辆追踪器中返回的是车辆位置的快照，而在使用委托的车辆追踪器中返回的是一个不可修改但却实时的车辆位置视图。这意味着，如果线程A调用getLocations，而线程B在随后修改了某些点的位置，那么在返回给线程A的Map中将反映出这些变化。在前面提到过，这可能是一种优点（更新的数据），也可能是一种缺点（可能导致不一致的车辆位置视图），具体情况取决于你的需求。

如果需要一个不发生变化的车辆视图，那么getLocations可以返回对locations这个Map对象的一个浅拷贝（Shallow Copy）。由于Map的内容是不可变的，因此只需复制Map的结构，而不用复制它的内容，如程序清单4-8所示（其中只返回一个HashMap，因为getLocations并不能保证返回一个线程安全的Map）。

```java
public Map＜String, Point＞getLocations（）{
  return Collections.unmodifiableMap（new HashMap＜String, Point＞（locations））；
}
```

#### 独立的状态变量

到目前为止，这些委托示例都仅仅委托给了单个线程安全的状态变量。

我们还可以将线程安全性委托给**多个状态变量**，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。

```java
public class VisualComponent {

  private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<>();

  private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<>();

  public void addKeyListener(KeyListener listener) {
    keyListeners.add(listener);
  }

  public void addMouseListener(MouseListener listener) {
    mouseListeners.add(listener);
  }

  public void removeKeyListener(KeyListener listener) {
    keyListeners.remove(listener);
  }

  public void removeMouseListener(MouseListener listener) {
    mouseListeners.remove(listener);
  }
}
```

> `VisualComponent`使用`CopyOnWriteArrayList`来保存各个监听器列表。它是一个线程安全的链表，特别适用于管理监听器列表（参见5.2.3节）。每个链表都是线程安全的，此外，由于各个状态之间不存在耦合关系，因此`VisualComponent`可以将它的线程安全性委托给`mouseListeners`和`keyListeners`等对象。

#### 当委托失效时

大多数组合对象都不会像  `VisualComponent` 这样简单：在它们的状态变量之间存在着某些不变性条件。

```java
public class NumberRange {

  // 不变性条件：lower＜=upper
  private final AtomicInteger lower = new AtomicInteger(0);
  private final AtomicInteger upper = new AtomicInteger(0);

  public void setLower(int i) {
    // 注意--不安全的 “先检查后执行”
    if (i > upper.get()) {
      throw new IllegalArgumentException("can't set lower to" + i + " > upper");
    }
    lower.set(i);
  }

  public void setUpper(int i) {
    if (i < lower.get()) {
      throw new IllegalArgumentException("can't set upper to " + i + " < lower");
    }
  }

  public boolean isInRange(int i) {
    return i >= lower.get() && i <= upper.get();
  }
}
```

> `NumberRange`不是线程安全的，没有维持对下界和上界进行约束的不变性条件。setLower和setUpper等方法都尝试维持不变性条件，但却无法做到。
>
> setLower和setUpper都是“先检查后执行”的操作，但它们没有使用足够的加锁机制来保证这些操作的原子性。假设取值范围为（0，10），如果一个线程调用setLower（5），而另一个线程调用setUpper（4），那么在一些错误的执行时序中，这两个调用都将通过检查，并且都能设置成功。结果得到的取值范围就是（5，4），那么这是一个无效的状态。
>
> 因此，虽然`AtomicInteger`是线程安全的，但经过组合得到的类却不是。由于状态变量lower和upper不是彼此独立的，因此`NumberRange`不能将线程安全性委托给它的线程安全状态变量。
>
> **`NumberRange`可以通过加锁机制来维护不变性条件以确保其线程安全性，例如使用一个锁来保护lower和upper。此外，它还必须避免发布lower和upper，从而防止客户代码破坏其不变性条件。**

- 如果某个
- 类含有复合操作，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。

- 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。
- 即使类的各个状态组成部分都是线程安全的，也不能确保类的线程安全性。

#### 发布底层的状态变量

当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能修改它们？

**答案仍然取决于在类中对这些变量施加了哪些不变性条件。**

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

#### 示例：发布状态的车辆追踪器

我们来构造车辆追踪器的另一个版本，并在这个版本中发布底层的可变状态。我们需要修改接口以适应这种变化，即使用可变且线程安全的Point类。

```java
@ThreadSafe
public class SafePoint {

  @GuardedBy("this")
  private int x;

  @GuardedBy("this")
  private int y;

  private SafePoint(int[] a) {
    this(a[0], a[1]);
  }

  public SafePoint(int x, int y) {
    this.x = x;
    this.y = y;
  }

  public SafePoint(SafePoint p) {
    this(p.get());
  }

  public synchronized int[] get() {
    return new int[] {x, y};
  }

  public synchronized void set(int x, int y) {
    this.x = x;
    this.y = y;
  }
}
```

> `SafePoint`提供的get方法同时获得x和y的值，并将二者放在一个数组中返回[^4.3.5.1]
>
> [^4.3.5.1]: 如果将拷贝构造函数实现为this（p.x, p.y），那么会产生竞态条件，而私有构造函数则可以避免这种竞态条件。这是私有构造函数捕获模式（PrivateConstructor Capture Idiom, Bloch and Gafter，2005）的一个实例。
>
> 。如果为x和y分别提供get方法，那么在获得这两个不同坐标的操作之间，x和y的值发生变化，从而导致调用者看到不一致的值：车辆从来没有到达过位置（x, y）。通过使用`SafePoint`，可以构造一个发布其底层可变状态的车辆追踪器，还能确保其线程安全性不被破坏

```java
@ThreadSafe
public class PublishingVehicleTracker {

  private final Map<String, SafePoint> locations;
  private final Map<String, SafePoint> unmodifiableMap;

  public PublishingVehicleTracker(Map<String, SafePoint> locations) {
    this.locations = new ConcurrentHashMap<>(locations);
    unmodifiableMap = Collections.unmodifiableMap(this.locations);
  }

  public Map<String, SafePoint> getLocations() {
    return unmodifiableMap;
  }

  public SafePoint getLocation(String id) {
    return locations.get(id);
  }

  public void setLocation(String id, int x, int y) {
    if (!locations.containsKey(id)) {
      throw new IllegalArgumentException("invalid vehicle name: " + id);
    }
    locations.get(id).set(x, y);
  }
}
```

> `PublishingVehicleTracker`将其线程安全性委托给底层的`ConcurrentHashMap`，只是Map中的元素是线程安全的且可变的Point，而并非不可变的。
>
> getLocation方法返回底层Map对象的一个不可变副本。调用者不能增加或删除车辆，但却可以通过修改返回Map中的SafePoint值来改变车辆的位置。
>
> 再次指出，Map的这种“实时”特性究竟是带来好处还是坏处，仍然取决于实际的需求。
>
> `PublishingVehicleTracker`是线程安全的，但如果它在车辆位置的有效值上施加了任何约束，那么就不再是线程安全的。
>
> 如果需要对车辆位置的变化进行判断或者当位置变化时执行一些操作，那么`PublishingVehicleTracker`中采用的方法并不合适。

### 在现有的线程安全类中添加功能

Java类库包含许多有用的“基础模块”类。通常，我们应该优先选择重用这些现有的类而不是创建新的类：重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。有时候，某个现有的线程安全类能支持我们需要的所有操作，但更多时候，现有的类只能支持大部分的操作，此时就需要在不破坏线程安全性的情况下添加一个新的操作。

##### 修改原始的类

这通常无法做到，因为你可能无法访问或修改类的源代码。

要想修改原始的类，就需要理解代码中的同步策略，这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解与维护。

##### 拓展这个类

`BetterVector`对Vector进行了扩展，并添加了一个新方法`putIfAbsent`。扩展Vector很简单，但并非所有的类都像Vector那样将状态向子类公开，因此也就不适合采用这种方法。

```java
@ThreadSafe
public class BetterVector<E> extends Vector<E> {

  @Serial private static final long serialVersionUID = -688925674924800348L;

  public synchronized boolean putIfAbsent(E e) {
    boolean absent = !contains(e);
    if (absent) {
      add(e);
    }
    return absent;
  }
}
```

**“扩展”方法比直接将代码添加到类中更加脆弱**，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。（在`Vector`的规范中定义了它的同步策略，因此`BetterVector`不存在这个问题。）

##### 客户端加锁机制

第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个“辅助类”中。

客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户代码。要使用客户端加锁，你必须知道对象X使用的是哪一个锁。

```java
@ThreadSafe
public class ListHelper<E> {

  private final List<E> list = Collections.synchronizedList(new ArrayList<>());

  public boolean putIfAbsent(E e) {
    synchronized (list) {
      boolean absent = !list.contains(e);
      if (absent) {
        list.add(e);
      }
      return absent;
    }
  }
}
```

**客户端加锁却更加脆弱**，因为它将类C的加锁代码放到与C完全无关的其他类中。当在那些并不承诺遵循加锁策略的类上使用客户端加锁时，要特别小心。

客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性，客户端加锁同样会破坏同步策略的封装性。

##### 组合

当为现有的类添加一个原子操作时，有一种更好的方法：组合（Composition）

```java
@ThreadSafe
public class ImprovedList<E> implements List<E> {

  private final List<E> list;

  public ImprovedList(List<E> list) {
    this.list = list;
  }

  public synchronized boolean putIfAbsent(E e) {
    boolean absent = !list.contains(e);
    if (absent) {
      list.add(e);
    }
    return absent;
  }
  
  // ....
}
```

> `ImprovedList`通过自身的内置锁增加了一层额外的加锁。它并不关心底层的List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，`ImprovedList`也会提供一致的加锁机制来实现线程安全性。
>
> 虽然额外的同步层可能导致轻微的性能损失，但与模拟另一个对象的加锁策略相比，`ImprovedList`更为健壮。
>
> 事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。

### 将同步策略文档化

在维护线程安全性时，文档是最强大的（同时也是最未被充分利用的）工具之一。用户可以通过查阅文档来判断某个类是否是线程安全的，而维护人员也可以通过查阅文档来理解其中的实现策略，避免在维护过程中破坏安全性。

在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

synchronized、volatile或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。这种策略是程序设计的要素之一，因此应该将其文档化。当然，设计阶段是编写设计决策文档的最佳时间。

在设计同步策略时需要考虑多个方面，例如，将哪些变量声明为volatile类型，哪些变量用锁来保护，哪些锁保护哪些变量，哪些变量必须是不可变的或者被封闭在线程中的，哪些操作必须是原子操作等。其中某些方面是严格的实现细节，应该将它们文档化以便于日后的维护。还有一些方面会影响类中加锁行为的外在表现，也应该将其作为规范的一部分写入文档。最起码，应该保证将类中的线程安全性文档化。它是否是线程安全的？在执行回调时是否持有一个锁？是否有某些特定的锁会影响其行为？不要让客户冒着风险去猜测。如果你不想支持客户端加锁也是可以的，但一定要明确地指出来。

如果某个类没有明确地声明是线程安全的，那么就不要假设它是线程安全的。

许多Java技术规范都没有（或者至少不愿意）说明接口的线程安全性，例如ServletContext、HttpSession或DataSource。
