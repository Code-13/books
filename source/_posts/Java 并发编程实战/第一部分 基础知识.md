---
date: 2021-10-27
cover: https://img2.doubanio.com/view/subject/l/public/s7663093.jpg
---

# 第一部分 基础知识

## 线程安全性

### 什么是线程安全性

> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

### 原子性

#### 竞态条件 Race Condition

> 当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件
> 大多是竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算

> 先检查后执行是最常见的竞态条件
> 读取-修改-写入 是另一种竞态条件

#### 原子操作

> 要避免竞态条件问题，就必须在某个线程修改变量时，通过**某种方式**防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中

> 原子操作是指，对于访问同一个状态的所有操作(包含该操作本身)来说，这个操作是一个以原子方式执行的操作
> 原子性：一组操作，要么全部执行，要么全部不执行

> 复合操作：包含了一组必须以原子方式执行的操作

### 加锁机制

> 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

#### 内置锁 `synchronized`

> 同步代码块包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块

```java
synchronized (lock) {
 // 访问或者修改由锁保护的共享状态
}
```

> 每个 Java 对象都可以作为一个实现同步的锁，这个锁统称为内置锁(Intrinsic Lock)或者监视器锁(Monitor Lock)
> Java 的内置锁是一种互斥锁

#### 可重入

Java 内置锁是可重入的

如果不可重入，可能会发生死锁

### 性能

> 通常，在简单性与性能之间存在相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能二牺牲简单性

> 当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁

## 对象的共享

> 同步还有另外一个重要的方面：内存可见性。我们不仅希望防止某个线程正在使用对象状态而另一个线程同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化

### 可见性

> 可见性时一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。

> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。即指令重排序

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。

#### `Volatile` 变量

- 被 `Volatile` 修饰的变量禁止指令重排序
- 保证可见性

> 仅当 volatile变量能简化代码的实现以及对同步策略的验证时，才使用

volatile 变量的正确使用方式：

- 确保它们自身状态的可见性
- 确保它们所引用对象的状态的可见性
- 标识一些重要的程序生命周期事件的发生

volatile 变量的局限性

- 不足以确保递增操作的原子性

何时使用 volatile 变量

- 对变量的写入操作不依赖变量的当前值，或者确保只有单个线程更新变量的值。
- 该变量不会与其他状态一起纳入不变性条件中
- 在访问变量时不需要加锁

### 线程封闭

> 当某个对象封闭在一个线程中时，这种用法将自动实现线程安全，即使被封闭的对象本身线程不安全

#### Ad-hoc 线程封闭

> 维护线程封闭性的职责完全由程序徐实现来承担。非常脆弱

#### 栈封闭

> 局部变量的固有属性之一就是封闭在执行线程中

#### ThreadLocal 类

> ThreadLocal 使线程中的某个值与保存值的对象关联起来

### 不变性

> 不可变对象一定是线程安全的

不可变对象需要满足的条件：

- 对象创建之后其状态就不能修改
- 对象的所有域都是 final
- 对象是正确创建的

### 总结

在并发程序中使用和共享对象时，可以采用一些实用的策略：

- 线程封闭
- 只读共享
- 线程安全共享
- 保护对象
