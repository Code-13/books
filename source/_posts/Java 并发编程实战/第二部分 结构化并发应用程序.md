# 结构化并发应用程序

[TOC]

## 任务执行

大多数并发应用程序都是围绕“任务执行（Task Execution）”来构造的：任务通常是一些抽象的且离散的工作单元。

### 在线程中执行任务

当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰的任务边界。在理想情况下，各个任务之间是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应。

目标：在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。应用程序提供商希望程序支持尽可能多的用户，从而降低每个用户的服务成本，而用户则希望获得尽快的响应。而且，当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。

#### 串行的执行任务

在应用程序中可以通过多种策略来调度任务，而其中一些策略能够更好地利用潜在的并发性。最简单的策略就是在单个线程中串行地执行各项任务。如 `SingleThreadWebServer` 所示：

```java
public class SingleThreadWebServer {

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      Socket connection = socket.accept();
      handleRequest(connection);
    }
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字I/O以读取请求和写回响应，这些操作通常会由于网络拥塞或连通性问题而被阻塞。此外，服务器还可能处理文件I/O或者数据库请求，这些操作同样会阻塞。在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻止等待中的请求被处理。如果请求阻塞的时间过长，用户将认为服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时，CPU将处于空闲状态。

在服务器应用程序中，串行处理机制通常都无法提供高吞吐率或快速响应性。也有一些例外，例如，当任务数量很少且执行时间很长时，或者当服务器只为单个用户提供服务，并且该客户每次只发出一个请求时——但大多数服务器应用程序并不是按照这种方式来工作的。

#### 显示的为任务创建线程

通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性，如`ThreadPerTaskWebServer`所示。

```java
public class ThreadPerTaskWebServer {

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      Socket connection = socket.accept();
      new Thread(() -> handleRequest(connection)).start();
    }
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

- 任务处理过程从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。
- 任务可以并行处理，从而能同时服务多个请求。如果有多个处理器，或者任务由于某种原因被阻塞，例如等待I/O完成、获取锁或者资源可用性等，程序的吞吐量将得到提高。
- 任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。

在正常负载情况下，“为每个任务分配一个线程”的方法能提升串行执行的性能。只要请求的到达速率不超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更高的吞吐率。

#### 无限制创建线程的不足

在生产环境中，“为每个任务分配一个线程”这种方法存在一些缺陷，尤其是当需要创建大量的线程时：

- 线程生命周期的开销非常高。线程的创建与销毁并不是没有代价的。根据平台的不同，实际的开销也有所不同，但线程的创建过程都会需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。
- 资源消耗。
  - 活跃的线程会消耗系统资源，尤其是内存。
  - 如果可运行的线程数量多于可用处理器的数量，那么有些线程将闲置。
  - 大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。
  - 如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。
- 稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么很可能抛出`OutOfMemoryError`异常。

**在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，并且如果过多地创建一个线程，那么整个应用程序将崩溃。**要想避免这种危险，就应该对应用程序可以创建的线程数量进行限制，并且全面地测试应用程序，从而确保在线程数量达到限制时，程序也不会耗尽资源。

### Executor 框架

任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。

线程池简化了线程的管理工作，并且 JUC 提供了一种灵活的线程池实现作为 Executor 框架的一部分。

在 Java 类库中，任务执行的主要抽象不是 Thread ，而是 Executor。

```java
public interface Executor {
  void execute(Runnable command);
}
```

虽然Executor是个简单的接口，但它却为灵活且强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。	

Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程则相当于消费者（执行完这些工作单元）。

#### 示例：基于 Executor 的 Web 服务器

`TaskExecutionWebServer` 使用了一种标准的Executor实现，即一个固定长度的线程池，可以容纳100个线程。

```java
public class TaskExecutionWebServer {

  private static final int NTHREADS = 100;

  private static final Executor executor = Executors.newFixedThreadPool(NTHREADS);

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      Socket connection = socket.accept();
      executor.execute(() -> handleRequest(connection));
    }
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

只需采用另一种不同的Executor实现，就可以改变服务器的行为。改变Executor实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。

我们还可以自定义 Executor 接口来实现不同的策略。

#### 执行策略

通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。

在执行策略中定义了任务执行的“What、Where、When、How”等方面，包括：

- 在什么（What）线程中执行任务？
- 任务按照什么（What）顺序执行（FIFO，LIFO，优先级）？
- 有多少个（How Many）任务能够并发执行？
- 在队列中有多少个（How Many）任务正在等待执行？
- 如果系统由于过载而需要拒绝一个任务，那么应选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？
- 在执行一个任务之前或之后，应该进行哪些（What）动作？

各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上发生竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。

#### 线程池

线程池，从定义上来看，是管理一组同构工作线程的资源池。线程池是与工作队列（Work Queue）密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Worker Thread）的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。

“在线程池中执行任务”比“为每个任务分配一个线程”优势更多：

- 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。
- 当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。
- 通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。
- 还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池：

- `newFixedThreadPool`。`newFixedThreadPool`将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。
- `newCachedThreadPool`。`newCachedThreadPool`将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，**线程池的规模不存在任何限制。**
- `newSingleThreadExecutor`。`newSingleThreadExecutor`是一个单线程的`Executor`，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。`newSingleThreadExecutor` 能确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）。单线程的Executor还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的。这意味着，即使这个线程会不时地被另一个线程替代，但对象总是可以安全地封闭在“任务线程”中。
- `newScheduledThreadPool`。`newScheduledThreadPool`创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。
- `newFixedThreadPool`和`newCachedThreadPool`这两个工厂方法返回通用的`ThreadPoolExecutor`实例，这些实例可以直接用来构造专门用途的executor。

Executor还可以实现各种调优、管理、监视、记录日志、错误报告和其他功能。

#### Executor 的生命周期

由于Executor以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。

关闭形式：

- 最平缓的关闭形式（完成所有已经启动的任务，并且不再接受任何新的任务）
- 最粗暴的关闭形式（直接关掉机房的电源）
- 以及其他各种可能的形式

Executor扩展了`ExecutorService`接口，添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：

```java
public interface ExecutorService extends Executor{
  	void shutdown（）；
    List＜Runnable＞shutdownNow（）；
    boolean isShutdown（）；
    boolean isTerminated（）；
    boolean awaitTermination（long timeout, TimeUnit unit）throws InterruptedException；
      //……其他用于任务提交的便利方法
}
```

`ExecutorService`的生命周期有3种状态：运行、关闭和已终止。

`ExecutorService`在初始创建时处于运行状态。

`shutdown`方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。`shutdownNow`方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。

在`ExecutorService`关闭后提交的任务将由“拒绝执行处理器（`RejectedExecutionHandler`）”来处理。它会抛弃任务，或者使得`execute`方法抛出一个未检查的`RejectedExecutionException`。

等所有任务都完成后，`ExecutorService`将转入终止状态。可以调用`awaitTermination`来等待`ExecutorService`到达终止状态，或者通过调用`isTerminated`来轮询`ExecutorService`是否已经终止。通常在调用`awaitTermination`之后会立即调用`shutdown`，从而产生同步地关闭`ExecutorService`的效果。

以下示例是一个执行关闭的 web 服务器：

```java
public class LifecycleWebServer {

  private static final int NTHREADS = 100;

  private static final ExecutorService executor = Executors.newFixedThreadPool(NTHREADS);

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (!executor.isShutdown()) {
      try {
        Socket connection = socket.accept();
        executor.execute(() -> handleRequest(connection));
      } catch (RejectedExecutionException e) {
        if (!executor.isShutdown()) {
          log("task submission rejected", e);
        }
      }
    }
  }

  public static void stop() {
    executor.shutdown();
  }

  private static void log(String msg, Exception e) {
    Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

####  延迟任务与周期任务

`Timer`类负责管理延迟任务（“在100ms后执行该任务”）以及周期任务（“每l0ms执行一次该任务”）。然而，`Timer`存在一些缺陷，因此应该考虑使用`ScheduledThreadPoolExecutor`来代替它。

- Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他`TimerTask`的定时精确性。
- `Timer`的另一个问题是，如果`TimerTask`抛出了一个未检查的异常，那么`Timer`将表现出糟糕的行为。Timer线程并不捕获异常，因此当`TimerTask`抛出未检查的异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的`TimerTask`将不会再执行，新的任务也不能被调度。这个问题称之为“线程泄漏[**Thread Leakage**]”

### 找出可利用的并行性

Executor框架帮助指定执行策略，但如果要使用Executor，必须将任务表述为一个Runnable。

在大多数服务器应用程序中都存在一个明显的任务边界：单个客户请求。但有时候，任务边界并非是显而易见的，例如在很多桌面应用程序中。即使是服务器应用程序，在单个客户请求中仍可能存在可发掘的并行性，例如数据库服务器。

示例组件实现浏览器程序中的页面渲染（Page-Rendering）功能，它的作用是将HTML页面绘制到图像缓存中。为了简便，假设HTML页面只包含标签文本，以及预定义大小的图片和URL。

#### 示例：串行的页面渲染器

最简单的方法就是对HTML文档进行串行处理。当遇到文本标签时，将其绘制到图像缓存中。当遇到图像引用时，先通过网络获取它，然后再将其绘制到图像缓存中。这很容易实现，程序只需将输入中的每个元素处理一次（甚至不需要缓存文档），但这种方法可能会令用户感到烦恼，他们必须等待很长时间，直到显示所有的文本。另一种串行执行方法更好一些，它先绘制文本元素，同时为图像预留出矩形的占位空间，在处理完了第一遍文本后，程序再开始下载图像，并将它们绘制到相应的占位空间中。

```java
public abstract class SingleThreadRenderer {

  void renderPage(CharSequence source) {
    rendText(source);

    List<ImageData> imageDataList = new ArrayList<>();
    for (ImageInfo imageInfo : scanForImageInfo(source)) {
      imageDataList.add(imageInfo.downloadImage());
    }

    for (ImageData imageData : imageDataList) {
      renderImage(imageData);
    }
  }

  abstract void rendText(CharSequence source);

  abstract List<ImageInfo> scanForImageInfo(CharSequence source);

  abstract void renderImage(ImageData imageData);

  interface ImageData {}

  interface ImageInfo {
    ImageData downloadImage();
  }
}
```

> 图像下载过程的大部分时间都是在等待I/O操作执行完成，在这期间CPU几乎不做任何工作。因此，这种串行执行方法没有充分地利用CPU，使得用户在看到最终页面之前要等待过长的时间。通过将问题分解为多个独立的任务并发执行，能够获得更高的CPU利用率和响应灵敏度。

#### 携带结果的任务Callable与Future

Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。

许多任务实际上都是存在延迟的计算——执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable是一种更好的抽象：它认为主入口点（即call）将返回一个值，并可能抛出一个异常。要使用Callable来表示无返回值的任务，可使用Callable＜Void＞。在Executor中包含了一些辅助方法能将其他类型的任务封装为一个Callable，例如Runnable和java.security.PrivilegedAction。

Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个生命周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。

Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退，就像`ExecutorService`的生命周期一样。当某个任务完成后，它就永远停留在“完成”状态上。

get方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为`ExecutionException`并重新抛出。如果任务被取消，那么get将抛出`CancellationException`。如果get抛出了`ExecutionException`，那么可以通过`getCause`来获得被封装的初始异常。

```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}

public interface Future<V> {

    /**
     * Attempts to cancel execution of this task.  This method has no
     * effect if the task is already completed or cancelled, or could
     * not be cancelled for some other reason.  Otherwise, if this
     * task has not started when {@code cancel} is called, this task
     * should never run.  If the task has already started, then the
     * {@code mayInterruptIfRunning} parameter determines whether the
     * thread executing this task (when known by the implementation)
     * is interrupted in an attempt to stop the task.
     *
     * <p>The return value from this method does not necessarily
     * indicate whether the task is now cancelled; use {@link
     * #isCancelled}.
     *
     * @param mayInterruptIfRunning {@code true} if the thread
     * executing this task should be interrupted (if the thread is
     * known to the implementation); otherwise, in-progress tasks are
     * allowed to complete
     * @return {@code false} if the task could not be cancelled,
     * typically because it has already completed; {@code true}
     * otherwise. If two or more threads cause a task to be cancelled,
     * then at least one of them returns {@code true}. Implementations
     * may provide stronger guarantees.
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns {@code true} if this task was cancelled before it completed
     * normally.
     *
     * @return {@code true} if this task was cancelled before it completed
     */
    boolean isCancelled();

    /**
     * Returns {@code true} if this task completed.
     *
     * Completion may be due to normal termination, an exception, or
     * cancellation -- in all of these cases, this method will return
     * {@code true}.
     *
     * @return {@code true} if this task completed
     */
    boolean isDone();

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     * @throws TimeoutException if the wait timed out
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

可以通过许多种方法创建一个`Future`来描述任务。`ExecutorService`中的所有`submit`方法都将返回一个`Future`，从而将一个`Runnable`或`Callable`提交给`Executor`，并得到一个`Future`用来获得任务的执行结果或者取消任务。还可以显式地为某个指定的`Runnable`或`Callable`实例化一个`FutureTask`。（由于`FutureTask`实现了`Runnable`，因此可以将它提交给`Executor`来执行，或者直接调用它的`run`方法。）

#### 示例：使用 Future 实现页面渲染器

为了使页面渲染器实现更高的并发性，首先将渲染过程分解为两个任务，

- 一个是渲染所有的文本，
- 另一个是下载所有的图像。

因为其中一个任务是CPU密集型，而另一个任务是I/O密集型，因此这种方法即使在单CPU系统上也能提升性能。

```java
public abstract class FutureRenderer {

  private final ExecutorService executor = Executors.newFixedThreadPool(100);

  void renderPage(CharSequence source) {

    List<ImageInfo> imageInfos = scanForImageInfo(source);

    Future<List<ImageData>> future =
        executor.submit(
            () -> {
              List<ImageData> imageDataList = new ArrayList<>();
              for (ImageInfo imageInfo : imageInfos) {
                imageDataList.add(imageInfo.downloadImage());
              }
              return imageDataList;
            });

    rendText(source);

    try {
      List<ImageData> imageDataList = future.get();
      for (ImageData imageData : imageDataList) {
        renderImage(imageData);
      }
    } catch (InterruptedException e) {
      // 重新设置线程的中断状态
      Thread.currentThread().interrupt();
      // 由于不需要结果，因此取消任务
      future.cancel(true);
    } catch (ExecutionException e) {
      throw LaunderThrowable.launderThrowable(e);
    }
  }

  abstract void rendText(CharSequence source);

  abstract List<ImageInfo> scanForImageInfo(CharSequence source);

  abstract void renderImage(ImageData imageData);

  interface ImageData {}

  interface ImageInfo {
    ImageData downloadImage();
  }
}
```

> `FutureRenderer`使得渲染文本任务与下载图像数据的任务并发地执行。当所有图像下载完后，会显示到页面上。这将提升用户体验，不仅使用户更快地看到结果，还有效利用了并行性，但我们还可以做得更好。用户不必等到所有的图像都下载完成，而希望看到每当下载完一幅图像时就立即显示出来。

#### 在异构任务并行化中存在的缺陷

两个人可以很好地分担洗碗的工作：其中一个人负责清洗，而另一个人负责烘干。然而，要将不同类型的任务平均分配给每个工人却并不容易。当人数增加时，如何确保他们能帮忙而不是妨碍其他人工作，或者在重新分配工作时，并不是容易的事情。**如果没有在相似的任务之间找出细粒度的并行性，那么这种方法带来的好处将减少。**

当在多个工人之间分配异构的任务时，还有一个问题就是各个任务的大小可能完全不同。为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。

**只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。**

#### `CompletionService`：`Executor`与`BlockingQueue`

如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout指定为0，从而通过轮询来判断任务是否完成。这种方法虽然可行，但却有些繁琐。幸运的是，还有一种更好的方法：完成服务（`CompletionService`）。

`CompletionService`将`Executor`和`BlockingQueue`的功能融合在一起。你可以将Callable任务提交给它来执行，然后使用类似于队列操作的`take`和`poll`等方法来获得已完成的结果，而这些结果会在完成时将被封装为`Future`。`ExecutorCompletionService`实现了`CompletionService`，并将计算部分委托给一个`Executor`。

`ExecutorCompletionService`的实现非常简单。在构造函数中创建一个`BlockingQueue`来保存计算完成的结果。当计算完成时，调用`FutureTask`中的done方法。当提交某个任务时，该任务将首先包装为一个`QueueingFuture`，这是`FutureTask`的一个子类，然后再改写子类的`done`方法，并将结果放入`BlockingQueue`中，take和poll方法委托给了`BlockingQueue`，这些方法会在得出结果之前阻塞。

```java
 private static class QueueingFuture<V> extends FutureTask<Void> {
   QueueingFuture(RunnableFuture<V> task,
                  BlockingQueue<Future<V>> completionQueue) {
     super(task, null);
     this.task = task;
     this.completionQueue = completionQueue;
   }
   private final Future<V> task;
   private final BlockingQueue<Future<V>> completionQueue;
   protected void done() { completionQueue.add(task); }
 }
```

#### 示例：使用 `completionService` 实现页面渲染器

```java
public abstract class Render {

  private final ExecutorService executor;

  public Render(ExecutorService executor) {
    this.executor = executor;
  }

  void renderPage(CharSequence source) {
    List<ImageInfo> imageInfos = scanForImageInfo(source);
    CompletionService<ImageData> completionService = new ExecutorCompletionService<>(executor);

    for (ImageInfo imageInfo : imageInfos) {
      completionService.submit(imageInfo::downloadImage);
    }

    renderText(source);

    int size = imageInfos.size();
    try {
      for (int i = 0; i < size; i++) {
        Future<ImageData> imageDataFuture = completionService.take();
        ImageData imageData = imageDataFuture.get();
        renderImage(imageData);
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
      throw LaunderThrowable.launderThrowable(e);
    }
  }

  protected abstract List<ImageInfo> scanForImageInfo(CharSequence source);

  protected abstract void renderText(CharSequence source);

  protected abstract void renderImage(ImageData imageData);

  interface ImageData {}

  interface ImageInfo {
    ImageData downloadImage();
  }
}
```

> 多个`ExecutorCompletionService`可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的`ExecutorCompletionService`。因此，`CompletionService`的作用就相当于一组计算的句柄，这与Future作为单个计算的句柄是非常类似的。通过记录提交给`CompletionService`的任务数量，并计算出已经获得的已完成结果的数量，即使使用一个共享的Executor，也能知道已经获得了所有任务结果的时间。

#### 为任务设置时限

有时候，如果某个任务无法在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。

在有限时间内执行任务的主要困难在于，要确保得到答案的时间不会超过限定的时间，或者在限定的时间内无法获得答案。在支持时间限制的Future.get中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出TimeoutException。

在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间，并且在超时后中止执行或取消任务。此时可再次使用Future，如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。

```java
public class RenderWithTimeBudget {

  private static final Ad DEFAULT_AD = new Ad();
  private static final long TIME_BUDGET = 1000;
  private static final ExecutorService exec = Executors.newCachedThreadPool();

  Page renderPageWithAd() throws InterruptedException {
    long end = System.nanoTime() + TIME_BUDGET;
    Future<Ad> f = exec.submit(Ad::new);
    Page page = renderPageBody();

    Ad ad;
    try {
      long timeLeft = end - System.nanoTime();
      ad = f.get(timeLeft, TimeUnit.NANOSECONDS);
    } catch (ExecutionException e) {
      ad = DEFAULT_AD;
    } catch (TimeoutException e) {
      ad = DEFAULT_AD;
      f.cancel(true);
    }

    page.setAd(ad);
    return page;
  }

  private Page renderPageBody() {
    return new Page();
  }

  static class Ad {}

  static class Page {
    public void setAd(Ad ad) {}
  }
}
```

> 示例中生成的页面中包括响应用户请求的内容以及从广告服务器上获得的广告。它将获取广告的任务提交给一个Executor，然后计算剩余的文本页面内容，最后等待广告信息，直到超出指定的时间。如果get超时，那么将取消[插图]广告获取任务，并转而使用默认的广告信息。

#### 示例：旅行预订门户网站

预定时间”方法可以很容易地扩展到任意数量的任务上。考虑这样一个旅行预定门户网站：用户输入旅行的日期和其他要求，门户网站获取并显示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用Web服务、访问数据库、执行一个EDI事务或其他机制。在这种情况下，不宜让页面的响应时间受限于最慢的响应时间，而应该只显示在指定时间内收到的信息。

从一个公司获得报价的过程与从其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使获得报价的过程能并发执行。创建n个任务，将其提交到一个线程池，保留n个Future，并使用限时的get方法通过Future串行地获取每一个结果，这一切都很简单，但还有一个更简单的方法——invokeAll。

```java
public class TimeBudget {

  private static ExecutorService executor = Executors.newCachedThreadPool();

  public List<TravelQuote> getRankedTravelQuotes(
      TravelInfo travelInfo,
      Set<TravelCompany> companies,
      Comparator<TravelQuote> ranking,
      long time,
      TimeUnit unit)
      throws InterruptedException {
    List<QuoteTask> tasks = new ArrayList<>();
    for (TravelCompany company : companies) {
      tasks.add(new QuoteTask(company, travelInfo));
    }

    List<Future<TravelQuote>> futures = executor.invokeAll(tasks, time, unit);

    List<TravelQuote> quotes = new ArrayList<>(tasks.size());
    for (Future<TravelQuote> future : futures) {
      for (QuoteTask task : tasks) {
        try {
          quotes.add(future.get());
        } catch (ExecutionException e) {
          quotes.add(task.getFailureQuote(e.getCause()));
        } catch (CancellationException e) {
          quotes.add(task.getTimeoutQuote(e));
        }
      }
    }

    quotes.sort(ranking);

    return quotes;
  }

  static class QuoteTask implements Callable<TravelQuote> {
    private final TravelCompany company;
    private final TravelInfo travelInfo;

    public QuoteTask(TravelCompany company, TravelInfo travelInfo) {
      this.company = company;
      this.travelInfo = travelInfo;
    }

    TravelQuote getFailureQuote(Throwable t) {
      return null;
    }

    TravelQuote getTimeoutQuote(CancellationException e) {
      return null;
    }

    @Override
    public TravelQuote call() throws Exception {
      return company.solicitQuote(travelInfo);
    }
  }
}

interface TravelCompany {
  TravelQuote solicitQuote(TravelInfo travelInfo) throws Exception;
}

interface TravelQuote {}

interface TravelInfo {}
```

### 小结

- 通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发。
- Executor框架将任务提交与执行策略解耦开来，同时还支持多种不同类型的执行策略。
- 当需要创建线程来执行任务时，可以考虑使用 executor 。
- 要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。
- 某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。

## 取消与关闭

任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。

要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断（Interruption），这是一种协作机制，能够使一个线程终止另一个线程的当前工作。

这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：当需要停止时，它们首先会清除当前正在执行的工作，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。

生命周期结束（End-of-Lifecycle）的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运行的软件之间的最主要区别就是，行为良好的软件能很完善地处理失败、关闭和取消等过程。本章将给出各种实现取消和中断的机制，以及如何编写任务和服务，使它们能对取消请求做出响应。

### 任务取消

如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的（Cancellable）。

取消某个操作的原因很多：

- 用户请求取消。
- 有时间限制的操作。
- 应用程序事件
- 错误
- 关闭

在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。

**其中一种协作机制能设置某个“已请求取消（Cancellation Requested）”标志，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。** 如示例 `PrimeGenerator` 所示：

```java
public class PrimeGenerator implements Runnable {

  @GuardedBy("this")
  private final List<BigInteger> primes = new ArrayList<>();

  private volatile boolean cancelled;

  @Override
  public void run() {
    BigInteger p = BigInteger.ONE;
    while (!cancelled) {
      p = p.nextProbablePrime();
      synchronized (this) {
        primes.add(p);
      }
    }
  }

  public void cancel() {
    cancelled = true;
  }

  public synchronized List<BigInteger> get() {
    return new ArrayList<>(primes);
  }

  static List<BigInteger> aSecondOfPrimes() throws InterruptedException {
    PrimeGenerator generator = new PrimeGenerator();
    new Thread(generator).start();
    try {
      SECONDS.sleep(1);
    } finally {
      generator.cancel();
    }
    return generator.get();
  }
}
```

> `PrimeGenerator`持续地枚举素数，直到它被取消。`cancel`方法将设置`cancelled`标志，并且主循环在搜索下一个素数之前会首先检查这个标志。（为了使这个过程能可靠地工作，标志`cancelled`必须为`volatile`类型。）
>
> `PrimeGenerator`使用了一种简单的取消策略：客户代码通过调用cancel来请求取消，`PrimeGenerator`在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。

**一个可取消的任务必须拥有取消策略（Cancellation Policy），在这个策略中将详细地定义取消操作的“How”、“When”以及“What”，即其他代码如何（How）请求取消该任务，任务在何时（When）检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（What）操作。**

#### 中断

`PrimeGenerator`中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。然而，如果使用这种方法的任务调用了一个阻塞方法，例如`BlockingQueue.put`，那么可能会产生一个更严重的问题——任务可能永远不会检查取消标志，因此永远不会结束。如示例 `BrokenPrimeProducer` 所示：

```java
@Terrible
public class BrokenPrimeProducer extends Thread {
  private final BlockingQueue<BigInteger> queue;
  private volatile boolean cancelled = false;

  public BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
    this.queue = queue;
  }

  @Override
  public void run() {
    BigInteger p = BigInteger.ONE;
    try {
      while (!cancelled) {
        queue.put(p.nextProbablePrime());
      }
    } catch (InterruptedException consumed) {
    }
  }

  public void cancel() {
    cancelled = true;
  }

  void consumePrimes() throws InterruptedException {
    BlockingQueue<BigInteger> primes = new ArrayBlockingQueue<>(100);
    BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);
    producer.start();
    try {
      while (needMorePrimes()) {
        consume(primes.take());
      }
    } finally {
      producer.cancel();
    }
  }

  private boolean needMorePrimes() {
    return true;
  }

  private void consume(BigInteger take) {}
}
```

> 生产者线程生成素数，并将它们放入一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，put方法也会阻塞。当生产者在put方法中阻塞时，如果消费者希望取消生产者任务，那么将发生什么情况？它可以调用cancel方法来设置cancelled标志，但此时生产者却永远不能检查这个标志，因为它无法从阻塞的put方法中恢复过来（因为消费者此时已经停止从队列中取出素数，所以put方法将一直保持阻塞状态）。

一些特殊的阻塞库的方法支持中断。线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。

在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。

**每个线程都有一个`boolean`类型的中断状态。当中断线程时，这个线程的中断状态将被设置为`true`。在`Thread`中包含了中断线程以及查询线程中断状态的方法，`interrupt`方法能中断目标线程，而`isInterrupted`方法能返回目标线程的中断状态。静态的`interrupted`方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。**

```java
public class Thread {
  public void interrupt（）{……}
  public boolean isInterrupted（）{……}
  public static boolean interrupted（）{……}
  ……
}
```

阻塞库方法，例如`Thread.sleep`和`Object.wait`等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：**清除中断状态，抛出`InterruptedException`**，表示阻塞操作由于中断而提前结束。JVM并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。

当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有黏性”——如果不触发`InterruptedException`，那么中断状态将一直保持，直到明确地清除中断状态。调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。

**对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。（这些时刻也被称为取消点）。**有些方法，例如wait、sleep和join等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求作出响应。

在使用静态的`interrupted`时应该小心，因为它会清除当前线程的中断状态。如果在调用`interrupted`时返回了`true`，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出`InterruptedException`，或者通过再次调用`interrupt`来恢复中断状态。

**如果任务代码能够响应中断，那么可以使用中断作为取消机制，并且利用许多库类中提供的中断支持。通常，中断是实现取消的最合理方式。**

示例如下：

```java
public class PrimeProducer extends Thread {
  private final BlockingQueue<BigInteger> queue;

  public PrimeProducer(BlockingQueue<BigInteger> queue) {
    this.queue = queue;
  }

  @Override
  public void run() {
    try {
      BigInteger p = BigInteger.ONE;
      while (!Thread.currentThread().isInterrupted()) {
        queue.put(p = p.nextProbablePrime());
      }
    } catch (InterruptedException ignored) {
      // allow thread exit
    }
  }

  public void cancel() {
    interrupt();
  }
}
```

#### 中断策略

正如任务中应该包含取消策略一样，线程同样应该包含中断策略。中断策略规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作（如果需要的话），哪些工作单元对于中断来说是原子操作，以及以多快的速度来响应中断。

最合理的中断策略是某种形式的线程级（Thread-Level）取消操作或服务级（Service-Level）取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务，但对于那些包含非标准中断策略的线程或线程池，只能用于能知道这些策略的任务中。

区分任务和线程对中断的反应是很重要的。一个中断请求可以有一个或多个接收者——中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。

任务不会在其自己拥有的线程中执行，而是在某个服务（例如线程池）拥有的线程中执行。**这就是为什么大多数可阻塞的库函数都只是抛出`InterruptedException`作为中断响应。**它们永远不会在某个由自己拥有的线程中运行，因此它们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。

任务不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中包含特定的中断策略。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心地保存执行线程的中断状态。如果除了将`InterruptedException`传递给调用者外还需要执行其他操作，那么应该在捕获`InterruptedException`之后恢复中断状态：

```java
Thread.currentThread().interrupt();
```

正如任务代码不应该对其执行所在的线程的中断策略做出假设，执行取消操作的代码也不应该对线程的中断策略做出假设。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭（shutdown）方法。

**由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。**

#### 响应中断

在前面的章节中，有两种实用策略可用于处理`InterruptedException`：

- 传递异常（可能在执行某个特定于任务的清除操作之后），从而使你的方法也成为可中断的阻塞方法。
- 恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。

只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。

对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获`InterruptedException`时恢复状态。如示例所示：

```java
public class NonCancelableTask {
  public Task getNextTask(BlockingQueue<Task> queue) {
    boolean interrupted = false;
    try {
      while (true) {
        try {
          return queue.take();
        } catch (InterruptedException e) {
          interrupted = true;
          // fall through and retry
        }
      }
    } finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }

  interface Task {}
}
```



如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之间进行权衡。如果响应性要求较高，那么不应该调用那些执行时间较长并且不响应中断的方法，从而对可调用的库代码进行一些限制。

在取消过程中可能涉及除了中断状态之外的其他状态。中断可以用来获得线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步的指示。（当访问这些信息时，要确保使用同步。）

#### 示例：计时运行

许多问题永远也无法解决（例如，枚举所有的素数），而某些问题，能很快得到答案，也可能永远得不到答案。在这些情况下，如果能够指定“最多花10分钟搜索答案”或者“枚举出在10分钟内能找到的答案”，那么将是非常有用的。

下面的示例在调用线程中运行任务，并安排了一个取消任务，在运行指定的时间间隔后中断它。这解决了从任务中抛出未检查异常的问题，因为该异常会被`timedRun`的调用者捕获。

```java
public class TimedRun1 {

  private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(1);

  public static void timedRun(Runnable r, long timeout, TimeUnit unit) {
    Thread taskThread = Thread.currentThread();
    cancelExec.schedule(taskThread::interrupt, timeout, unit);
    r.run();
  }
}
```

这是一种非常简单的方法，但却破坏了以下规则：在中断线程之前，应该了解它的中断策略。由于timedRun可以从任意一个线程中调用，因此它无法知道这个调用线程的中断策略。如果任务在超时之前完成，那么中断timedRun所在线程的取消任务将在timedRun返回到调用者之后启动。我们不知道在这种情况下将运行什么代码，但结果一定是不好的。（可以使用schedule返回的ScheduledFuture来取消这个取消任务以避免这种风险，这种做法虽然可行，但却非常复杂。）而且，如果任务不响应中断，那么timedRun会在任务结束时才返回，此时可能已经超过了指定的时限（或者还没有超过时限）。如果某个限时运行的服务没有在指定的时间内返回，那么将对调用者带来负面影响。

下个示例解决了之前解决方案中的问题。

```java
public class TimedRun2 {

  private static final ScheduledExecutorService cancelExec = newScheduledThreadPool(1);

  public static void timedRun(Runnable r, long timeout, TimeUnit unit) throws InterruptedException {
    class RethrowableTask implements Runnable {
      private volatile Throwable t;

      @Override
      public void run() {
        try {
          r.run();
        } catch (Throwable t) {
          this.t = t;
        }
      }

      void rethrow() {
        if (t != null) {
          throw launderThrowable(t);
        }
      }
    }

    RethrowableTask task = new RethrowableTask();
    Thread taskThread = new Thread(task);
    taskThread.start();
    cancelExec.schedule(
        new Runnable() {
          @Override
          public void run() {
            taskThread.interrupt();
          }
        },
        timeout,
        unit);
    taskThread.join(unit.toMillis(timeout));
    task.rethrow();
  }
}
```

> 在这个示例的代码中解决了前面示例中的问题，但由于它依赖于一个限时的join，因此存在着join的不足：无法知道执行控制是因为线程正常退出而返回还是因为join超时而返回。
>
> 这是Thread API的一个缺陷，因为无论join是否成功地完成，在Java内存模型中都会有内存可见性结果，但join本身不会返回某个状态来表明它是否成功。
