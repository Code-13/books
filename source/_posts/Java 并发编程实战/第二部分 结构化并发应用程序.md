# 结构化并发应用程序

[TOC]

## 任务执行

大多数并发应用程序都是围绕“任务执行（Task Execution）”来构造的：任务通常是一些抽象的且离散的工作单元

### 在线程中执行任务

当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰的任务边界。在理想情况下，各个任务之间是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应。

目标：在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。应用程序提供商希望程序支持尽可能多的用户，从而降低每个用户的服务成本，而用户则希望获得尽快的响应。而且，当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。

#### 串行的执行任务

在应用程序中可以通过多种策略来调度任务，而其中一些策略能够更好地利用潜在的并发性。最简单的策略就是在单个线程中串行地执行各项任务。如 `SingleThreadWebServer` 所示：

```java
public class SingleThreadWebServer {

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      Socket connection = socket.accept();
      handleRequest(connection);
    }
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字I/O以读取请求和写回响应，这些操作通常会由于网络拥塞或连通性问题而被阻塞。此外，服务器还可能处理文件I/O或者数据库请求，这些操作同样会阻塞。在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻止等待中的请求被处理。如果请求阻塞的时间过长，用户将认为服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时，CPU将处于空闲状态。

在服务器应用程序中，串行处理机制通常都无法提供高吞吐率或快速响应性。也有一些例外，例如，当任务数量很少且执行时间很长时，或者当服务器只为单个用户提供服务，并且该客户每次只发出一个请求时——但大多数服务器应用程序并不是按照这种方式来工作的。

#### 显示的为任务创建线程

通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性，如`ThreadPerTaskWebServer`所示。

```java
public class ThreadPerTaskWebServer {

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      Socket connection = socket.accept();
      new Thread(() -> handleRequest(connection)).start();
    }
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

- 任务处理过程从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。
- 任务可以并行处理，从而能同时服务多个请求。如果有多个处理器，或者任务由于某种原因被阻塞，例如等待I/O完成、获取锁或者资源可用性等，程序的吞吐量将得到提高。
- 任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。

在正常负载情况下，“为每个任务分配一个线程”的方法能提升串行执行的性能。只要请求的到达速率不超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更高的吞吐率。

#### 无限制创建线程的不足

在生产环境中，“为每个任务分配一个线程”这种方法存在一些缺陷，尤其是当需要创建大量的线程时：

- 线程生命周期的开销非常高。线程的创建与销毁并不是没有代价的。根据平台的不同，实际的开销也有所不同，但线程的创建过程都会需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。
- 资源消耗。
  - 活跃的线程会消耗系统资源，尤其是内存。
  - 如果可运行的线程数量多于可用处理器的数量，那么有些线程将闲置。
  - 大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。
  - 如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。
- 稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么很可能抛出`OutOfMemoryError`异常。

**在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，并且如果过多地创建一个线程，那么整个应用程序将崩溃。**要想避免这种危险，就应该对应用程序可以创建的线程数量进行限制，并且全面地测试应用程序，从而确保在线程数量达到限制时，程序也不会耗尽资源。

### Executor 框架

任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。

线程池简化了线程的管理工作，并且 JUC 提供了一种灵活的线程池实现作为 Executor 框架的一部分。

在 Java 类库中，任务执行的主要抽象不是 Thread ，而是 Executor。

```java
public interface Executor {
  void execute(Runnable command);
}
```

虽然Executor是个简单的接口，但它却为灵活且强大的异步任务执行框架提供了基础，该框架能支持多种不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。	

Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程则相当于消费者（执行完这些工作单元）。

#### 示例：基于 Executor 的 Web 服务器

`TaskExecutionWebServer` 使用了一种标准的Executor实现，即一个固定长度的线程池，可以容纳100个线程。

```java
public class TaskExecutionWebServer {

  private static final int NTHREADS = 100;

  private static final Executor executor = Executors.newFixedThreadPool(NTHREADS);

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      Socket connection = socket.accept();
      executor.execute(() -> handleRequest(connection));
    }
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

只需采用另一种不同的Executor实现，就可以改变服务器的行为。改变Executor实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。

我们还可以自定义 Executor 接口来实现不同的策略。

#### 执行策略

通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。

在执行策略中定义了任务执行的“What、Where、When、How”等方面，包括：

- 在什么（What）线程中执行任务？
- 任务按照什么（What）顺序执行（FIFO，LIFO，优先级）？
- 有多少个（How Many）任务能够并发执行？
- 在队列中有多少个（How Many）任务正在等待执行？
- 如果系统由于过载而需要拒绝一个任务，那么应选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？
- 在执行一个任务之前或之后，应该进行哪些（What）动作？

各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上发生竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。

#### 线程池

线程池，从定义上来看，是管理一组同构工作线程的资源池。线程池是与工作队列（Work Queue）密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Worker Thread）的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。

“在线程池中执行任务”比“为每个任务分配一个线程”优势更多：

- 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。
- 当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。
- 通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。
- 还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池：

- `newFixedThreadPool`。`newFixedThreadPool`将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。
- `newCachedThreadPool`。`newCachedThreadPool`将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，**线程池的规模不存在任何限制。**
- `newSingleThreadExecutor`。`newSingleThreadExecutor`是一个单线程的`Executor`，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。`newSingleThreadExecutor` 能确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）。单线程的Executor还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的。这意味着，即使这个线程会不时地被另一个线程替代，但对象总是可以安全地封闭在“任务线程”中。
- `newScheduledThreadPool`。`newScheduledThreadPool`创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。
- `newFixedThreadPool`和`newCachedThreadPool`这两个工厂方法返回通用的`ThreadPoolExecutor`实例，这些实例可以直接用来构造专门用途的executor。

Executor还可以实现各种调优、管理、监视、记录日志、错误报告和其他功能。

#### Executor 的生命周期

由于Executor以异步方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。

关闭形式：

- 最平缓的关闭形式（完成所有已经启动的任务，并且不再接受任何新的任务）
- 最粗暴的关闭形式（直接关掉机房的电源）
- 以及其他各种可能的形式

Executor扩展了`ExecutorService`接口，添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：

```java
public interface ExecutorService extends Executor{
  	void shutdown（）；
    List＜Runnable＞shutdownNow（）；
    boolean isShutdown（）；
    boolean isTerminated（）；
    boolean awaitTermination（long timeout, TimeUnit unit）throws InterruptedException；
      //……其他用于任务提交的便利方法
}
```

`ExecutorService`的生命周期有3种状态：运行、关闭和已终止。

`ExecutorService`在初始创建时处于运行状态。

`shutdown`方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。`shutdownNow`方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。

在`ExecutorService`关闭后提交的任务将由“拒绝执行处理器（`RejectedExecutionHandler`）”来处理。它会抛弃任务，或者使得`execute`方法抛出一个未检查的`RejectedExecutionException`。

等所有任务都完成后，`ExecutorService`将转入终止状态。可以调用`awaitTermination`来等待`ExecutorService`到达终止状态，或者通过调用`isTerminated`来轮询`ExecutorService`是否已经终止。通常在调用`awaitTermination`之后会立即调用`shutdown`，从而产生同步地关闭`ExecutorService`的效果。

以下示例是一个执行关闭的 web 服务器：

```java
public class LifecycleWebServer {

  private static final int NTHREADS = 100;

  private static final ExecutorService executor = Executors.newFixedThreadPool(NTHREADS);

  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (!executor.isShutdown()) {
      try {
        Socket connection = socket.accept();
        executor.execute(() -> handleRequest(connection));
      } catch (RejectedExecutionException e) {
        if (!executor.isShutdown()) {
          log("task submission rejected", e);
        }
      }
    }
  }

  public static void stop() {
    executor.shutdown();
  }

  private static void log(String msg, Exception e) {
    Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
  }

  private static void handleRequest(Socket connection) {
    // handle request
  }
}
```

####  延迟任务与周期任务

`Timer`类负责管理延迟任务（“在100ms后执行该任务”）以及周期任务（“每l0ms执行一次该任务”）。然而，`Timer`存在一些缺陷，因此应该考虑使用`ScheduledThreadPoolExecutor`来代替它。

- Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他`TimerTask`的定时精确性。
- `Timer`的另一个问题是，如果`TimerTask`抛出了一个未检查的异常，那么`Timer`将表现出糟糕的行为。Timer线程并不捕获异常，因此当`TimerTask`抛出未检查的异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的`TimerTask`将不会再执行，新的任务也不能被调度。这个问题称之为“线程泄漏[**Thread Leakage**]”

